import {
    app, BrowserWindow, dialog, ipcMain, shell, protocol, ProtocolRequest, ProtocolResponse
} from "electron";
import fs from "fs-extra";
import path from "path";
import { execFile } from "child_process";
import { Character, CharacterList, CharacterDat, CharacterPalette } from "./interfaces";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow;

function isNumber(num: string): boolean {
    return /^\+?(0|[1-9]\d*)$/.test(num);
}

function createWindow(): void {
    // Create the browser window.
    mainWindow = new BrowserWindow({
        width: 1120,
        height: 630,
        minWidth: 810,
        minHeight: 600,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
        autoHideMenuBar: true,
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    // mainWindow.webContents.openDevTools();

    createHandlers();
    protocol.registerFileProtocol("img", (
        request: ProtocolRequest,
        callback: (response: string | ProtocolResponse) => void
    ) => {
        const url = request.url.replace("img://", "");
        return callback(url);
    });
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
    app.quit();
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit();
    }
});

app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

function createHandlers(): void {
    ipcMain.handle("getGameDir", getGameDir);
    ipcMain.handle("getGameVersion",
        (event, args: Parameters<typeof getGameVersion>) => getGameVersion(...args)
    );
    ipcMain.handle("isValidGameDir",
        (event, args: Parameters<typeof isValidGameDir>) => isValidGameDir(...args)
    );
    ipcMain.handle("selectGameDir", selectGameDir);
    ipcMain.handle("openDir",
        (event, args: Parameters<typeof openDir>) => openDir(...args)
    );
    ipcMain.handle("runGame",
        (event, args: Parameters<typeof runGame>) => runGame(...args)
    );
    ipcMain.handle("openExternal",
        (event, args: Parameters<typeof shell.openExternal>) => shell.openExternal(...args)
    );
    ipcMain.handle("getCharacters",
        (event, args: Parameters<typeof getCharacters>) => getCharacters(...args)
    );
    ipcMain.handle("getCharacterList",
        (event, args: Parameters<typeof getCharacterList>) => getCharacterList(...args)
    );
    ipcMain.handle("writeCharacterRandom",
        (event, args: Parameters<typeof writeCharacterRandom>) => writeCharacterRandom(...args)
    );
    ipcMain.handle("extractCharacter",
        (event, args: Parameters<typeof extractCharacter>) => extractCharacter(...args)
    );
    ipcMain.handle("getCharacterDat",
        (event, args: Parameters<typeof getCharacterDat>) => getCharacterDat(...args)
    );
}

const SUPPORTED_VERSIONS: string[] = [
    "CMC_v8",
    "CMC+ v8",
];

const CHARACTER_FILES = [
    "arcade/routes/<fighter>.txt",
    "data/<fighter>.dat",
    "data/dats/<fighter>.dat",
    "fighter/<fighter>.bin",
    "fighter/<fighter>",
    "gfx/abust/<fighter>.png",
    "gfx/bust/<fighter>.png",
    "gfx/bust/<fighter>_<palette>.png",
    "gfx/cbust/<fighter>.png",
    "gfx/mbust/<fighter>.png",
    "gfx/tbust/<fighter>__*.png",
    "gfx/mugs/<fighter>.png",
    "gfx/hudicon/<series>.png",
    "gfx/name/<fighter>.png",
    "gfx/portrait/<fighter>.png",
    "gfx/portrait/<fighter>_<palette>.png",
    "gfx/portrait_new/<fighter>.png",
    "gfx/portrait_new/<fighter>_<palette>.png",
    "gfx/seriesicon/<series>.png",
    "gfx/stock/<fighter>.png",
    "palettes/<fighter>",
    "music/versus/<fighter>_*.<audio>",
    "music/victory/<series>.<audio>",
    "music/victory/individual/<fighter>.<audio>",
    "sfx/announcer/fighter/<fighter>.<audio>",
    "sticker/common/<fighter>.png",
    "sticker/common/desc/<fighter>.txt",
    "sticker/rare/<fighter>.png",
    "sticker/rare/desc/<fighter>.txt",
    "sticker/super/<fighter>.png",
    "sticker/super/desc/<fighter>.txt",
    "sticker/ultra/<fighter>.png",
    "sticker/ultra/desc/<fighter>.txt",
];

const DATA_FILE = path.join(app.getPath("userData"), "data.json");
if (!fs.existsSync(DATA_FILE)) {
    writeJSON(DATA_FILE, {
        dir: "",
    });
}

let gameDir: string = readJSON(DATA_FILE).dir;

function readJSON(file: string): any {
    return JSON.parse(fs.readFileSync(file, "utf-8"));
}

function writeJSON(file: string, data: object): void {
    fs.writeFileSync(file, JSON.stringify(data, null, 4), "utf-8");
}

function getAllFiles(dirPath: string, arrayOfFiles?: string[]): string[] {
    const files: string[] = fs.readdirSync(dirPath);

    arrayOfFiles = arrayOfFiles || [];

    files.forEach(function (file) {
        if (fs.statSync(dirPath + "/" + file).isDirectory()) {
            arrayOfFiles = getAllFiles(dirPath + "/" + file, arrayOfFiles);
        } else {
            arrayOfFiles.push(path.join(dirPath, "/", file));
        }
    });

    return arrayOfFiles;
}

async function getGameDir(): Promise<string> {
    return gameDir;
}

async function getGameVersion(
    dir: string = gameDir,
    list: string[] = SUPPORTED_VERSIONS
): Promise<string | null> {
    if (dir == null) {
        return null;
    }
    for (const game of list) {
        if (fs.existsSync(path.join(dir, game + ".exe"))) {
            return game;
        }
    }
    return null;
}

async function isValidGameDir(dir: string = gameDir): Promise<boolean> {
    return (dir != null && await getGameVersion(dir) != null);
}

async function selectGameDir(): Promise<string | null> {
    const dir = await dialog.showOpenDialog(mainWindow, {
        properties: ["openDirectory"]
    });
    if (dir.canceled == true) {
        return null;
    }
    if (!await isValidGameDir(dir.filePaths[0])) {
        //TODO: inform the user
        return null;
    }

    getAllFiles(dir.filePaths[0]).forEach((file: string) => {
        fs.chmod(file, 0o777);
    });
    gameDir = dir.filePaths[0];
    const data: any = readJSON(DATA_FILE);
    data.dir = gameDir;
    writeJSON(DATA_FILE, data);
    return gameDir;
}

async function openDir(dir: string): Promise<void> {
    shell.openPath(dir);
}

async function runGame(dir: string = gameDir): Promise<void> {
    execFile(path.join(dir, await getGameVersion(gameDir) + ".exe"), {
        cwd: dir,
        windowsHide: true
    });
}

async function getCharacters(dir: string = gameDir): Promise<Character[]> {
    return (await getCharacterList(dir)).getAllCharacters();
}

async function getCharacterList(dir: string = gameDir): Promise<CharacterList> {
    const characters: CharacterList = new CharacterList();
    const charactersTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighters.txt"),
        "ascii"
    ).split(/\r?\n/);
    charactersTxt.shift(); // Drop the number
    charactersTxt.forEach(async (character: string, index: number) => {
        if (fs.existsSync(path.join(dir, "data", "dats", character + ".dat"))) {
            const characterDat: CharacterDat = await getCharacterDat(character, dir);
            characters.addCharacter({
                name: character,
                displayName: characterDat.displayName,
                series: characterDat.series,
                randomSelection: true, // Assume true and then iterate through false list
                cssNumber: index + 1,
                // alts: []
                mug: path.join(dir, "gfx", "mugs", character + ".png")
            });
        }
    });
    const lockedTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighter_lock.txt"),
        "ascii"
    ).split(/\r?\n/);
    lockedTxt.shift();
    lockedTxt.forEach((locked: string) => {
        characters.updateCharacterByName(locked, { randomSelection: false });
    });
    return characters;
}

async function writeCharacterRandom(
    character: string,
    randomSelection: boolean,
    dir: string = gameDir
): Promise<void> {
    let lockedTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighter_lock.txt"),
        "ascii"
    ).split(/\r?\n/);
    lockedTxt.shift();
    if (randomSelection) {
        lockedTxt = lockedTxt.filter((locked: string) => locked != character);
    } else {
        lockedTxt.push(character);
    }
    let output = lockedTxt.length.toString() + "\r\n";
    output += lockedTxt.join("\r\n");
    fs.writeFile(
        path.join(dir, "data", "fighter_lock.txt"),
        output,
        { encoding: "ascii" }
    )
}

async function getCharacterDat(character: string, dir: string = gameDir): Promise<CharacterDat> {
    return readCharacterDat(path.join(dir, "data", "dats", character + ".dat"), character);
}

async function readCharacterDat(
    datPath: string,
    character: string = path.parse(datPath).name
): Promise<CharacterDat> {
    const characterDatTxt: string[] = fs.readFileSync(
        datPath,
        "ascii"
    ).split(/\r?\n/);
    // 4th Line is numeric = vanilla dat
    // Also location might mean vanilla dat
    // else if the 5th line is numeric it is a v7 dat
    const isVanilla = isNumber(characterDatTxt[3]);
    const isV7 = isVanilla || isNumber(characterDatTxt[6]);

    const homeStages: string[] = [];
    const randomDatas: string[] = [];
    const palettes: CharacterPalette[] = [];
    if (isV7) {
        homeStages.push("battlefield");
        randomDatas.push("Updated to v8 dat format by CMC Mod Manager");
        const paletteCount: number =
        parseInt(characterDatTxt[isVanilla ? 1 : 5]);
        for (let palette = 1; palette <= paletteCount * 6; palette += 6) {
            const paletteLocation: number = isVanilla ? 1 : 5 + palette;
            palettes.push({
                name: characterDatTxt[paletteLocation + 0],
                0: parseInt(characterDatTxt[paletteLocation + 1]),
                1: parseInt(characterDatTxt[paletteLocation + 2]),
                2: parseInt(characterDatTxt[paletteLocation + 3]),
                3: parseInt(characterDatTxt[paletteLocation + 4]),
                4: parseInt(characterDatTxt[paletteLocation + 5])
            });
        }
    } else {
        const homeStageCount: number = parseInt(characterDatTxt[5]);
        for (let stage = 1; stage <= homeStageCount; stage++) {
            homeStages.push(characterDatTxt[5 + stage]);
        }

        const randomDataCount: number = parseInt(characterDatTxt[7 + homeStageCount]);
        for (let data = 1; data <= randomDataCount; data++) {
            randomDatas.push(characterDatTxt[7 + homeStageCount + data]);
        }

        const paletteCount: number =
            parseInt(characterDatTxt[9 + homeStageCount + randomDataCount]);
        for (let palette = 1; palette <= paletteCount * 6; palette += 6) {
            const paletteLocation: number = 10 + homeStageCount + randomDataCount + palette;
            palettes.push({
                name: characterDatTxt[paletteLocation + 0],
                0: parseInt(characterDatTxt[paletteLocation + 1]),
                1: parseInt(characterDatTxt[paletteLocation + 2]),
                2: parseInt(characterDatTxt[paletteLocation + 3]),
                3: parseInt(characterDatTxt[paletteLocation + 4]),
                4: parseInt(characterDatTxt[paletteLocation + 5])
            });
        }
    }
    return {
        name: character,
        displayName: characterDatTxt[0],
        menuName: characterDatTxt[1],
        battleName: characterDatTxt[2],
        series: characterDatTxt[3].toLowerCase(),
        homeStages: homeStages,
        randomDatas: randomDatas,
        palettes: palettes
    };
}

async function writeDat(dat: CharacterDat, destination: string): Promise<void> {
    let output = [
        dat.displayName,
        dat.menuName,
        dat.battleName,
        dat.series,
        "---Classic Home Stages Below---",
        dat.homeStages.length,
        dat.homeStages.join("\r\n"),
        "---Random Datas---",
        dat.randomDatas.length,
        dat.randomDatas.join("\r\n"),
        "---Palettes Number---",
        dat.palettes.length,
        "---From Here is Individual Palettes data---"
    ].join("\r\n");
    dat.palettes.forEach((palette: CharacterPalette) => {
        output += [
            "",
            palette.name,
            palette[0],
            palette[1],
            palette[2],
            palette[3],
            palette[4]
        ].join("\r\n");
    });
    fs.writeFile(path.join(destination, dat.name), output, { encoding: "ascii" });
}

async function extractCharacter(character: string, dir: string = gameDir): Promise<void> {
    //
}

function filterCharacterFiles(characterDat: CharacterDat, ignoreSeries = false): string[] {
    const files: string[] = [];
    CHARACTER_FILES.forEach((file: string) => {
        const fixedFiles: string[] = [];
        let replaced: string = file.replaceAll("<fighter>", characterDat.name);
        if (!ignoreSeries) replaced = replaced.replaceAll("<series>", characterDat.series);
        fixedFiles.push(replaced);
        if (fixedFiles[0].includes("<audio>")) {
            ["ogg", "wav", "mp3"].forEach((format: string) => {
                fixedFiles.push(fixedFiles[0].replaceAll("<audio>", format));
            });
            fixedFiles.shift();
        }
        fixedFiles.forEach((fixedFile: string) => {
            if (fixedFile.includes("<palette>")) {
                characterDat.palettes.forEach((palette: CharacterPalette, index: number) => {
                    fixedFiles.push(fixedFile.replaceAll("<palette>", String(index + 1)));
                });
                fixedFiles.shift();
            }
        });
        fixedFiles.forEach((fixed: string) => {
            files.push(fixed);
        })
    });
    return files;
}