import { app, BrowserWindow, dialog, ipcMain, shell, protocol } from "electron";
import fs from "fs-extra";
import path from "path";
import { execFile } from "child_process";
import { Character } from "./interfaces";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow;

function createWindow(): void {
    // Create the browser window.
    mainWindow = new BrowserWindow({
        width: 1120,
        height: 630,
        minWidth: 810,
        minHeight: 600,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
        autoHideMenuBar: true,
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    // mainWindow.webContents.openDevTools();

    createHandlers();
    protocol.registerFileProtocol("img", (request, callback) => {
        const url = request.url.replace("img://", "");
        return callback(url);
    });
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
    app.quit();
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit();
    }
});

app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

function createHandlers(): void {
    ipcMain.handle("getGameDir", getGameDir);
    ipcMain.handle("getGameVersion",
        (event, args: Parameters<typeof getGameVersion>) => getGameVersion(...args)
    );
    ipcMain.handle("isValidGameDir",
        (event, args: Parameters<typeof isValidGameDir>) => isValidGameDir(...args)
    );
    ipcMain.handle("selectGameDir", selectGameDir);
    ipcMain.handle("openDir",
        (event, args: Parameters<typeof openDir>) => openDir(...args)
    );
    ipcMain.handle("runGame",
        (event, args: Parameters<typeof runGame>) => runGame(...args)
    );
    ipcMain.handle("openExternal",
        (event, args: Parameters<typeof shell.openExternal>) => shell.openExternal(...args)
    );
    ipcMain.handle("getCharacters",
        (event, args: Parameters<typeof getCharacters>) => getCharacters(...args)
    );
}

const SUPPORTED_VERSIONS: string[] = [
    "CMC_v8",
    "CMC+ v8",
];

const DATA_FILE = path.join(app.getPath("userData"), "data.json");
if (!fs.existsSync(DATA_FILE)) {
    writeJSON(DATA_FILE, {
        dir: "",
    });
}

let gameDir: string = readJSON(DATA_FILE).dir;

function readJSON(file: string): any {
    return JSON.parse(fs.readFileSync(file, "utf-8"));
}

function writeJSON(file: string, data: object): void {
    fs.writeFileSync(file, JSON.stringify(data, null, 4), "utf-8");
}

function getAllFiles(dirPath: string, arrayOfFiles?: string[]): string[] {
    const files = fs.readdirSync(dirPath);

    arrayOfFiles = arrayOfFiles || [];

    files.forEach(function (file) {
        if (fs.statSync(dirPath + "/" + file).isDirectory()) {
            arrayOfFiles = getAllFiles(dirPath + "/" + file, arrayOfFiles);
        } else {
            arrayOfFiles.push(path.join(dirPath, "/", file));
        }
    });

    return arrayOfFiles;
}

async function getGameDir(): Promise<string> {
    return gameDir;
}

async function getGameVersion(
    dir: string = gameDir,
    list: string[] = SUPPORTED_VERSIONS
): Promise<string | null> {
    if (dir == null) {
        return null;
    }
    for (const game of list) {
        if (fs.existsSync(path.join(dir, game + ".exe"))) {
            return game;
        }
    }
    return null;
}

async function isValidGameDir(dir: string = gameDir): Promise<boolean> {
    return (dir != null && await getGameVersion(dir) != null);
}

async function selectGameDir(): Promise<string | null> {
    const dir = await dialog.showOpenDialog(mainWindow, {
        properties: ["openDirectory"]
    });
    if (dir.canceled == true) {
        return null;
    }
    if (!await isValidGameDir(dir.filePaths[0])) {
        //TODO: inform the user
        return null;
    }

    getAllFiles(dir.filePaths[0]).forEach((file) => {
        fs.chmod(file, 0o777);
    });
    gameDir = dir.filePaths[0];
    const data: any = readJSON(DATA_FILE);
    data.dir = gameDir;
    writeJSON(DATA_FILE, data);
    return gameDir;
}

async function openDir(dir: string): Promise<void> {
    shell.openPath(dir);
}

async function runGame(dir: string = gameDir): Promise<void> {
    execFile(path.join(dir, await getGameVersion(gameDir) + ".exe"), {
        cwd: dir,
        windowsHide: true
    });
}

async function getCharacters(dir: string = gameDir): Promise<Character[]> {
    const characters: Character[] = [];
    const charactersTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighters.txt"),
        "ascii"
    ).split(/\r?\n/);
    charactersTxt.shift(); // Drop the number
    charactersTxt.forEach((character: string, index: number) => {
        if (fs.existsSync(path.join(dir, "data", "dats", character + ".dat"))) {
            const characterDat = fs.readFileSync(
                path.join(dir, "data", "dats", character + ".dat"),
                "ascii"
            ).split(/\r?\n/);
            characters.push({
                name: character,
                displayName: characterDat[1],
                series: characterDat[3].toLowerCase(),
                randomSelection: true, //TODO:
                cssNumber: index + 1,
                // alts: []
                mug: path.join(dir, "gfx", "mugs", character + ".png")
            });
        }
    });
    return characters;
}