import {
    app, BrowserWindow, dialog, ipcMain, shell, protocol, ProtocolRequest, ProtocolResponse
} from "electron";
import fs from "fs-extra";
import path from "path";
import { execFile } from "child_process";
import { Character, CharacterList, CharacterDat, CharacterPalette } from "./interfaces";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow;

function isNumber(num: string): boolean {
    return /^\+?(0|[1-9]\d*)$/.test(num);
}

function createWindow(): void {
    // Create the browser window.
    mainWindow = new BrowserWindow({
        width: 1120,
        height: 630,
        minWidth: 810,
        minHeight: 600,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
        autoHideMenuBar: true,
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    // mainWindow.webContents.openDevTools();

    createHandlers();
    protocol.registerFileProtocol("img", (
        request: ProtocolRequest,
        callback: (response: string | ProtocolResponse) => void
    ) => {
        const url = request.url.replace("img://", "");
        return callback(url);
    });
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
    app.quit();
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit();
    }
});

app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

function createHandlers(): void {
    ipcMain.handle("getGameDir", getGameDir);
    ipcMain.handle("getExtractedDir", getExtractedDir);
    ipcMain.handle("getGameVersion",
        (event, args: Parameters<typeof getGameVersion>) => getGameVersion(...args)
    );
    ipcMain.handle("isValidGameDir",
        (event, args: Parameters<typeof isValidGameDir>) => isValidGameDir(...args)
    );
    ipcMain.handle("selectGameDir", selectGameDir);
    ipcMain.handle("openDir",
        (event, args: Parameters<typeof openDir>) => openDir(...args)
    );
    ipcMain.handle("runGame",
        (event, args: Parameters<typeof runGame>) => runGame(...args)
    );
    ipcMain.handle("openExternal",
        (event, args: Parameters<typeof shell.openExternal>) => shell.openExternal(...args)
    );
    ipcMain.handle("getCharacters",
        (event, args: Parameters<typeof getCharacters>) => getCharacters(...args)
    );
    ipcMain.handle("readCharacterList",
        (event, args: Parameters<typeof readCharacterList>) => readCharacterList(...args)
    );
    ipcMain.handle("writeCharacterList",
        (event, args: Parameters<typeof writeCharacterList>) => writeCharacterList(...args)
    );
    ipcMain.handle("writeCharacterRandom",
        (event, args: Parameters<typeof writeCharacterRandom>) => writeCharacterRandom(...args)
    );
    ipcMain.handle("extractCharacter",
        (event, args: Parameters<typeof extractCharacter>) => extractCharacter(...args)
    );
    ipcMain.handle("removeCharacter",
        (event, args: Parameters<typeof removeCharacter>) => removeCharacter(...args)
    );
    ipcMain.handle("getCharacterDat",
        (event, args: Parameters<typeof getCharacterDat>) => getCharacterDat(...args)
    );
    ipcMain.handle("readCharacterDat",
        (event, args: Parameters<typeof readCharacterDat>) => readCharacterDat(...args)
    );
    ipcMain.handle("writeCharacterDat",
        (event, args: Parameters<typeof writeCharacterDat>) => writeCharacterDat(...args)
    );
    ipcMain.handle("filterCharacterFiles",
        (event, args: Parameters<typeof filterCharacterFiles>) => filterCharacterFiles(...args)
    );
}

const PROGRAM_DIR = app.getPath("userData");

const SUPPORTED_VERSIONS: string[] = [
    "CMC_v8",
    "CMC+ v8",
];

const CHARACTER_FILES = [
    "arcade/routes/<fighter>.txt",
    "data/<fighter>.dat",
    "data/dats/<fighter>.dat",
    "fighter/<fighter>.bin",
    "fighter/<fighter>",
    "gfx/abust/<fighter>.png",
    "gfx/bust/<fighter>.png",
    "gfx/bust/<fighter>_<palette>.png",
    "gfx/cbust/<fighter>.png",
    "gfx/mbust/<fighter>.png",
    "gfx/tbust/<fighter>__*.png",
    "gfx/mugs/<fighter>.png",
    "gfx/hudicon/<series>.png",
    "gfx/name/<fighter>.png",
    "gfx/portrait/<fighter>.png",
    "gfx/portrait/<fighter>_<palette>.png",
    "gfx/portrait_new/<fighter>.png",
    "gfx/portrait_new/<fighter>_<palette>.png",
    "gfx/seriesicon/<series>.png",
    "gfx/stock/<fighter>.png",
    "palettes/<fighter>",
    "music/versus/<fighter>_*.<audio>",
    "music/victory/<series>.<audio>",
    "music/victory/individual/<fighter>.<audio>",
    "sfx/announcer/fighter/<fighter>.<audio>",
    "sticker/common/<fighter>.png",
    "sticker/common/desc/<fighter>.txt",
    "sticker/rare/<fighter>.png",
    "sticker/rare/desc/<fighter>.txt",
    "sticker/super/<fighter>.png",
    "sticker/super/desc/<fighter>.txt",
    "sticker/ultra/<fighter>.png",
    "sticker/ultra/desc/<fighter>.txt",
];

const DATA_FILE = path.join(app.getPath("userData"), "data.json");
if (!fs.existsSync(DATA_FILE)) {
    writeJSON(DATA_FILE, {
        dir: "",
    });
}

let gameDir: string = readJSON(DATA_FILE).dir;

function readJSON(file: string): any {
    return JSON.parse(fs.readFileSync(file, "utf-8"));
}

function writeJSON(file: string, data: object): void {
    fs.writeFileSync(file, JSON.stringify(data, null, 4), "utf-8");
}

function getAllFiles(dirPath: string, arrayOfFiles?: string[]): string[] {
    const files: string[] = fs.readdirSync(dirPath);

    arrayOfFiles = arrayOfFiles || [];

    files.forEach(function (file) {
        if (fs.statSync(dirPath + "/" + file).isDirectory()) {
            arrayOfFiles = getAllFiles(dirPath + "/" + file, arrayOfFiles);
        } else {
            arrayOfFiles.push(path.join(dirPath, "/", file));
        }
    });

    return arrayOfFiles;
}

function getGameDir(): string {
    return gameDir;
}

function getExtractedDir(): string {
    return path.join(gameDir, "extracted");
}

function getGameVersion(
    dir: string = gameDir,
    list: string[] = SUPPORTED_VERSIONS
): string | null {
    if (dir == null) {
        return null;
    }
    for (const game of list) {
        if (fs.existsSync(path.join(dir, game + ".exe"))) {
            return game;
        }
    }
    return null;
}

async function isValidGameDir(dir: string = gameDir): Promise<boolean> {
    return (dir != null && getGameVersion(dir) != null);
}

async function selectGameDir(): Promise<string | null> {
    const dir = await dialog.showOpenDialog(mainWindow, {
        properties: ["openDirectory"]
    });
    if (dir.canceled == true) {
        return null;
    }
    if (!await isValidGameDir(dir.filePaths[0])) {
        //TODO: inform the user
        return null;
    }

    getAllFiles(dir.filePaths[0]).forEach((file: string) => {
        fs.chmod(file, 0o777);
    });
    gameDir = dir.filePaths[0];
    const data: any = readJSON(DATA_FILE);
    data.dir = gameDir;
    writeJSON(DATA_FILE, data);
    return gameDir;
}

async function openDir(dir: string): Promise<void> {
    shell.openPath(dir);
}

async function runGame(dir: string = gameDir): Promise<void> {
    execFile(path.join(dir, getGameVersion(gameDir) + ".exe"), {
        cwd: dir,
        windowsHide: true
    });
}

function getCharacters(dir: string = gameDir): Character[] {
    return readCharacterList(dir).getAllCharacters();
}

function readCharacterList(dir: string = gameDir): CharacterList {
    // console.log(new Date().getTime());
    const characters: CharacterList = new CharacterList();
    const charactersTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighters.txt"),
        "ascii"
    ).split(/\r?\n/);
    charactersTxt.shift(); // Drop the number
    charactersTxt.forEach((character: string, index: number) => {
        if (fs.existsSync(path.join(dir, "data", "dats", character + ".dat"))) {
            const characterDat: CharacterDat = getCharacterDat(character, dir);
            characters.addCharacter({
                name: character,
                displayName: characterDat.displayName,
                series: characterDat.series,
                randomSelection: true, // Assume true and then iterate through false list
                cssNumber: index + 1,
                // alts: []
                mug: path.join(dir, "gfx", "mugs", character + ".png")
            });
        }
    });
    const lockedTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighter_lock.txt"),
        "ascii"
    ).split(/\r?\n/);
    lockedTxt.shift();
    lockedTxt.forEach((locked: string) => {
        characters.updateCharacterByName(locked, { randomSelection: false });
    });
    // console.log(new Date().getTime());
    return characters;
}

async function writeCharacterList(
    characterList: CharacterList,
    dir: string = gameDir
): Promise<void> {
    console.log(characterList);
    const characters: Character[] = characterList.getAllCharacters();
    characters.sort((a: Character, b: Character) => 
        (a.cssNumber > b.cssNumber ? 1 : -1)
    );
    const output: string = [
        characters.length,
        characters.map((character: Character) => character.name).join("\r\n")
    ].join("\r\n");
    fs.writeFile(
        path.join(dir, "data", "fighters.txt"),
        output,
        { encoding: "ascii" }
    );
}

// async function getCharacters(dir: string = gameDir): Promise<Character[]> {
//     return (await readCharacterList(dir)).getAllCharacters();
// }

// async function readCharacterList(dir: string = gameDir): Promise<CharacterList> {
//     // console.log(new Date().getTime());
//     const characters: CharacterList = new CharacterList();
//     const charactersTxtPromise: Promise<string> = fs.readFile(
//         path.join(dir, "data", "fighters.txt"),
//         { encoding: "ascii" }
//     );// Drop the number
//     const lockedTxtPromise: Promise<string> = fs.readFile(
//         path.join(dir, "data", "fighter_lock.txt"),
//         { encoding: "ascii" }
//     );
//     const [charactersTxt, lockedTxt]: [string, string] = await Promise.all(
//         [charactersTxtPromise, lockedTxtPromise]
//     );
//     const charactersList: string[] = charactersTxt.split(/\r?\n/);
//     const lockedList: string[] = lockedTxt.split(/\r?\n/);
//     charactersList.shift(); 
//     lockedList.shift();
//     charactersList.forEach(async (character: string, index: number) => {
//         if (fs.existsSync(path.join(dir, "data", "dats", character + ".dat"))) {
//             const characterDat: CharacterDat = getCharacterDat(character, dir);
//             characters.addCharacter({
//                 name: character,
//                 displayName: characterDat.displayName,
//                 series: characterDat.series,
//                 randomSelection: lockedList.includes(character),
//                 cssNumber: index + 1,
//                 // alts: []
//                 mug: path.join(dir, "gfx", "mugs", character + ".png")
//             });
//         }
//     });
//     // console.log(new Date().getTime());
//     return characters;
// }

async function writeCharacterRandom(
    character: string,
    randomSelection: boolean,
    dir: string = gameDir
): Promise<void> {
    let lockedTxt: string[] = fs.readFileSync(
        path.join(dir, "data", "fighter_lock.txt"),
        "ascii"
    ).split(/\r?\n/);
    lockedTxt.shift();
    if (randomSelection) {
        lockedTxt = lockedTxt.filter((locked: string) => locked != character);
    } else {
        lockedTxt.push(character);
    }
    let output = lockedTxt.length.toString() + "\r\n";
    output += lockedTxt.join("\r\n");
    fs.writeFile(
        path.join(dir, "data", "fighter_lock.txt"),
        output,
        { encoding: "ascii" }
    )
}

function getCharacterDat(character: string, dir: string = gameDir): CharacterDat {
    return readCharacterDat(path.join(dir, "data", "dats", character + ".dat"), character);
}

function readCharacterDat(
    datPath: string,
    character: string = path.parse(datPath).name
): CharacterDat {
    const characterDatTxt: string[] = fs.readFileSync(
        datPath,
        "ascii"
    ).split(/\r?\n/);
    // TODO: handle empty v7 names for builtin characters
    const isVanilla = isNumber(characterDatTxt[3]);
    const isV7 = isVanilla || isNumber(characterDatTxt[4]);

    let displayName: string;
    let menuName: string;
    let battleName: string;
    let series: string;
    // TODO: get input for 
    if (isVanilla) {
        displayName = "TODO";
        menuName = "TODO";
        battleName = "TODO";
        series = "TODO";
    } else {
        displayName = characterDatTxt[0];
        menuName = characterDatTxt[1];
        battleName = characterDatTxt[2];
        series = characterDatTxt[3].toLowerCase();
    }

    const homeStages: string[] = [];
    const randomDatas: string[] = [];
    const palettes: CharacterPalette[] = [];
    if (isV7) {
        homeStages.push("battlefield");
        randomDatas.push("Updated to v8 dat format by CMC Mod Manager");
        const paletteCount: number =
        parseInt(characterDatTxt[isVanilla ? 1 : 5]);
        for (let palette = 1; palette <= paletteCount * 6; palette += 6) {
            const paletteLocation: number = isVanilla ? 1 : 5 + palette;
            palettes.push({
                name: characterDatTxt[paletteLocation + 0],
                0: parseInt(characterDatTxt[paletteLocation + 1]),
                1: parseInt(characterDatTxt[paletteLocation + 2]),
                2: parseInt(characterDatTxt[paletteLocation + 3]),
                3: parseInt(characterDatTxt[paletteLocation + 4]),
                4: parseInt(characterDatTxt[paletteLocation + 5])
            });
        }
    } else {
        const homeStageCount: number = parseInt(characterDatTxt[5]);
        for (let stage = 1; stage <= homeStageCount; stage++) {
            homeStages.push(characterDatTxt[5 + stage]);
        }

        const randomDataCount: number = parseInt(characterDatTxt[7 + homeStageCount]);
        for (let data = 1; data <= randomDataCount; data++) {
            randomDatas.push(characterDatTxt[7 + homeStageCount + data]);
        }

        const paletteCount: number =
            parseInt(characterDatTxt[9 + homeStageCount + randomDataCount]);
        for (let palette = 1; palette <= paletteCount * 6; palette += 6) {
            const paletteLocation: number = 10 + homeStageCount + randomDataCount + palette;
            palettes.push({
                name: characterDatTxt[paletteLocation + 0],
                0: parseInt(characterDatTxt[paletteLocation + 1]),
                1: parseInt(characterDatTxt[paletteLocation + 2]),
                2: parseInt(characterDatTxt[paletteLocation + 3]),
                3: parseInt(characterDatTxt[paletteLocation + 4]),
                4: parseInt(characterDatTxt[paletteLocation + 5])
            });
        }
    }
    return {
        name: character,
        displayName: displayName,
        menuName: menuName,
        battleName: battleName,
        series: series,
        homeStages: homeStages,
        randomDatas: randomDatas,
        palettes: palettes
    };
}

async function writeCharacterDat(dat: CharacterDat, destination: string): Promise<void> {
    let output = [
        dat.displayName,
        dat.menuName,
        dat.battleName,
        dat.series,
        "---Classic Home Stages Below---",
        dat.homeStages.length,
        dat.homeStages.join("\r\n"),
        "---Random Datas---",
        dat.randomDatas.length,
        dat.randomDatas.join("\r\n"),
        "---Palettes Number---",
        dat.palettes.length,
        "---From Here is Individual Palettes data---"
    ].join("\r\n");
    dat.palettes.forEach((palette: CharacterPalette) => {
        output += [
            "",
            palette.name,
            palette[0],
            palette[1],
            palette[2],
            palette[3],
            palette[4]
        ].join("\r\n");
    });
    fs.ensureFileSync(path.join(destination, dat.name + ".dat"));
    fs.writeFile(path.join(destination, dat.name + ".dat"), output, { encoding: "ascii" });
}

async function extractCharacter(extract: string, dir: string = gameDir): Promise<void> {
    const characters: Character[] = getCharacters(dir);
    const similarNames: string[] = [];
    characters.forEach((character: Character) => {
        if (character.name.includes(extract) && character.name != extract) {
            similarNames.push(character.name);
        }
    });
    const characterDat: CharacterDat = getCharacterDat(extract, dir);
    const extractDir: string = path.join(dir, "extracted", extract);
    filterCharacterFiles(characterDat).forEach((file: string) => {
        const subDir: string = path.parse(file).dir;
        if (file.includes("*")) {
            const start: string = path.parse(file).base.split("*")[0].replace(subDir, "");
            const end: string = path.parse(file).base.split("*")[1];
            if (fs.existsSync(path.join(dir, subDir))) {
                const contents: string[] = fs.readdirSync(path.join(dir, subDir))
                    .filter((i: string) => {
                        similarNames.forEach((name: string) => {
                            if (i.startsWith(name)) {
                                console.log(i + " was ignored because it belongs to " + name);
                                return false;
                            }
                        });
                        return i.startsWith(start) && i.endsWith(end);
                    });
                contents.forEach((found) => {
                    console.log("Extracting: " + path.join(dir, subDir, found));
                    fs.copy(
                        path.join(dir, subDir, found),
                        path.join(extractDir, subDir, found),
                        { overwrite: true }
                    );
                });
            }
        } else {
            const target: string = path.join(dir, file);
            if (fs.existsSync(target)) {
                console.log("Extracting: " + target);
                fs.copy(target, path.join(extractDir, subDir, file), { overwrite: true });
            }
        }
    });
    writeCharacterDat(
        characterDat,
        path.join(extractDir, "data", "dats", characterDat.name + ".dat")
    );
}

async function removeCharacter(remove: string, dir: string = gameDir): Promise<void> {
    const characters: CharacterList = readCharacterList(dir);
    const similarNames: string[] = [];
    characters.getAllCharacters().forEach((character: Character) => {
        if (character.name.includes(remove) && character.name != remove) {
            similarNames.push(character.name);
        }
    });
    const characterDat: CharacterDat = getCharacterDat(remove, dir);
    filterCharacterFiles(characterDat, true).forEach((file: string) => {
        const subDir: string = path.parse(file).dir;
        if (file.includes("*")) {
            const start: string = path.parse(file).base.split("*")[0].replace(subDir, "");
            const end: string = path.parse(file).base.split("*")[1];
            if (fs.existsSync(path.join(dir, subDir))) {
                const contents: string[] = fs.readdirSync(path.join(dir, subDir))
                    .filter((i: string) => {
                        similarNames.forEach((name: string) => {
                            if (i.startsWith(name)) {
                                console.log(i + " was ignored because it belongs to " + name);
                                return false;
                            }
                        });
                        return i.startsWith(start) && i.endsWith(end);
                    });
                contents.forEach((found) => {
                    console.log("Removing: " + path.join(dir, subDir, found));
                    fs.remove(path.join(dir, subDir, found));
                });
            }
        } else {
            const target: string = path.join(dir, file);
            if (fs.existsSync(target)) {
                console.log("Removing: " + target);
                fs.remove(target);
            }
        }
    });
    characters.removeCharacterByName(remove);
    writeCharacterList(characters, dir);
    //TODO: Remove from CSS
}

function filterCharacterFiles(characterDat: CharacterDat, ignoreSeries = false): string[] {
    const files: string[] = [];
    CHARACTER_FILES.forEach((file: string) => {
        const fixedFiles: string[] = [];
        let replaced: string = file.replaceAll("<fighter>", characterDat.name);
        if (!ignoreSeries) replaced = replaced.replaceAll("<series>", characterDat.series);
        fixedFiles.push(replaced);
        if (fixedFiles[0].includes("<audio>")) {
            ["ogg", "wav", "mp3"].forEach((format: string) => {
                fixedFiles.push(fixedFiles[0].replaceAll("<audio>", format));
            });
            fixedFiles.shift();
        }
        fixedFiles.forEach((fixedFile: string) => {
            if (fixedFile.includes("<palette>")) {
                characterDat.palettes.forEach((palette: CharacterPalette, index: number) => {
                    fixedFiles.push(fixedFile.replaceAll("<palette>", String(index)));
                });
                fixedFiles.shift();
            }
        });
        fixedFiles.forEach((fixed: string) => {
            files.push(fixed);
        })
    });
    return files;
}